# Nanopore Bioinformatics

## Description

Collection of notes and workflows relating to the storage, processing and assembly of Nanopore-obtained sequencing

## Tool Collection

### Assembly

* [canu](https://canu.readthedocs.io/en/latest/)<br>Canu is a fork of the Celera Assembler designed for high-noise single-molecule sequencing (such as the PacBio RSII or Oxford Nanopore MinION).

* [shasta](https://github.com/chanzuckerberg/shasta)<br>The goal of the Shasta long read assembler is to rapidly produce accurate assembled sequence using as input DNA reads generated by Oxford Nanopore flow cells.

  Computational methods used by the Shasta assembler include:

  - Using a [run-length](https://en.wikipedia.org/wiki/Run-length_encoding) representation of the read sequence. This makes the assembly process more resilient to errors in homopolymer repeat counts, which are the most common type of errors in Oxford Nanopore reads.
  - Using in some phases of the computation a representation of the read sequence based on *markers*, a fixed subset of short k-mers (k â‰ˆ 10).

  An initial implementation of the Shasta assembler is complete and functional, but significant improvements in several areas are possible. As currently implemented, it can run an assembly of a human genome at coverage around 60x in about 5 hours using a single, large machine (AWS instance type `x1.32xlarge`, with 128 virtual processors and 1952 GB of memory). The compute cost of such an assembly is around $20 at AWS spot market or reserved prices.

  The accuracy of assembled sequence is being analyzed. Early indications are that Shasta is similar or better in assembly quality when compared to other long read assemblers.

* [Katuali/pomoxis/miniasm](https://github.com/nanoporetech/katuali)<br>Katuali is a flexible consensus pipeline implemented in Snakemake to basecall, assemble, and polish Oxford Nanopore Technologies' sequencing data.

  * fast5 to high quality assembly in a single command.
  * Recommended fixed "standard" and "fast" pipelines.
  * Interchange basecaller, assembler, and consensus components of the pipelines simply by changing the target filepath.
  * [Medaka](https://github.com/nanoporetech/medaka) training pipeline including generation of training data, model training, and model evaluation.
  * Seemless distribution of tasks over local or distributed compute.
  * Open source (Mozilla Public License 2.0).

* [Unicycler]( https://github.com/rrwick/Unicycler)<br>Unicycler is an assembly pipeline for bacterial genomes. It can assemble [Illumina](http://www.illumina.com/)-only read sets where it functions as a [SPAdes](http://cab.spbu.ru/software/spades/)-optimiser. It can also assembly long-read-only sets ([PacBio](http://www.pacb.com/) or [Nanopore](https://nanoporetech.com/)) where it runs a [miniasm](https://github.com/lh3/miniasm)+[Racon](https://github.com/isovic/racon) pipeline. For the best possible assemblies, give it both Illumina reads *and* long reads, and it will conduct a hybrid assembly.

### Consensus / polishing

* [racon](https://github.com/lbcb-sci/racon)<br>Racon is intended as a standalone consensus module to correct raw contigs generated by rapid assembly methods which do not include a consensus step. The goal of Racon is to generate genomic consensus which is of similar or better quality compared to the output generated by assembly methods which employ both error correction and consensus steps, while providing a speedup of several times compared to those methods. It supports data produced by both Pacific Biosciences and Oxford Nanopore Technologies.
* [medaka]( https://github.com/nanoporetech/medaka )<br>medak is a tool to create a consensus sequence from nanopore sequencing data. This task is performed using neural networks applied from a pileup of individual sequencing reads against a draft assembly. It outperforms graph-based methods operating on basecalled data, and can be competitive with state-of-the-art signal-based methods, whilst being much faster.
* [nanopolish]( https://github.com/jts/nanopolish)<br>Software package for signal-level analysis of Oxford Nanopore sequencing data. Nanopolish can calculate an improved consensus sequence for a draft genome assembly, detect base modifications, call SNPs and indels with respect to a reference genome and more (see Nanopolish modules, below).

### Basecalling

* [guppy](https://community.nanoporetech.com/downloads)<br>Guppy is a data processing toolkit that contains the Oxford Nanopore Technologies' basecalling algorithms, and several bioinformatic post-processing features. It is provided as binaries to run on Windows, OS X and Linux platforms, as well as being integrated with MinKNOW, the Oxford Nanopore device control software.

### Phasing

* [whatshap](https://whatshap.readthedocs.io/en/latest/)<br>WhatsHap is a software for phasing genomic variants using DNA sequencing reads, also called *read-based phasing* or *haplotype assembly*. It is especially suitable for long reads, but works also well with short reads.
* [marginphase](https://github.com/benedictpaten/marginPhase)<br>MarginPhase is a program for simultaneous haplotyping and genotyping.

### Demultiplexing

* [qcat](https://github.com/nanoporetech/qcat)<br>qcat is Python command-line tool for demultiplexing Oxford Nanopore reads from FASTQ files. It accepts basecalled FASTQ files and splits the reads into into separate FASTQ files based on their barcode. Qcat makes the demultiplexing algorithms used in albacore/guppy and EPI2ME available to be used locally with FASTQ files. Currently qcat implements the EPI2ME algorithm. In the next version we will add the albacore/guppy algorithm.
* [guppy](https://community.nanoporetech.com/downloads)<br>Guppy is a data processing toolkit that contains the Oxford Nanopore Technologies' basecalling algorithms, and several bioinformatic post-processing features. It is provided as binaries to run on Windows, OS X and Linux platforms, as well as being integrated with MinKNOW, the Oxford Nanopore device control software.

### Structural variant calling

* [sniffles](https://github.com/fritzsedlazeck/Sniffles)<br>Sniffles is a structural variation caller using third generation sequencing (PacBio or Oxford Nanopore). It detects all types of SVs (10bp+) using evidence from split-read alignments, high-mismatch regions, and coverage analysis. Please note the current version of Sniffles requires sorted output from BWA-MEM (use -M and -x parameter), Minimap2 (sam file with Cigar & MD string) or NGMLR
* [svim](https://github.com/eldariont/svim)<br>SVIM (pronounced *SWIM*) is a structural variant caller for long reads. It is able to detect, classify and genotype five different classes of structural variants. Unlike existing methods, SVIM integrates information from across the genome to precisely distinguish similar events, such as tandem and interspersed duplications and novel element insertions. In our experiments on simulated data and real datasets from PacBio and Nanopore sequencing machines, SVIM reached consistently better results than competing methods. Furthermore, it is unique in its capability of extracting both the genomic origin and destination of duplications.

### Small variant calling

* [medaka](https://github.com/nanoporetech/medaka)<br>medaka is a tool to create a consensus sequence from nanopore sequencing data. This task is performed using neural networks applied from a pileup of individual sequencing reads against a draft assembly. It outperforms graph-based methods operating on basecalled data, and can be competitive with state-of-the-art signal-based methods, whilst being much faster.
* [clair](https://github.com/HKU-BAL/Clair)<br>Single-molecule sequencing technologies have emerged in recent years and revolutionized structural variant calling, complex genome assembly, and epigenetic mark detection. However, the lack of a highly accurate small variant caller has limited the new technologies from being more widely used. In this study, we present Clair, the successor to Clairvoyante, a program for fast and accurate germline small variant calling, using single molecule sequencing data. For ONT data, Clair achieves the best precision, recall and speed as compared to several competing programs, including Clairvoyante, Longshot and Medaka. Through studying the missed variants and benchmarking intentionally overfitted models, we found that Clair may be approaching the limit of possible accuracy for germline small variant calling using pileup data and deep neural networks.
* [megalodon](https://github.com/nanoporetech/megalodon)<br>Megalodon is a research tool for per-read and aggregated modified base and sequence variant calling by anchoring the information rich basecalling neural network output to a reference genome/transriptome. Megalodon takes raw nanopore reads as input and produces multiple outputs, primarily including basecalls (FASTA), reference mappings (SAM/BAM/CRAM), sequence variant calls (per-read and VCF) and modified base calls (per-read and bedgraph/bedmethyl/VCF).

### Mapping

* [minimap2](https://github.com/lh3/minimap2)<br>Minimap2 is a versatile sequence alignment program that aligns DNA or mRNA sequences against a large reference database. Typical use cases include: (1) mapping PacBio or Oxford Nanopore genomic reads to the human genome; (2) finding overlaps between long reads with error rate up to ~15%; (3) splice-aware alignment of PacBio Iso-Seq or Nanopore cDNA or Direct RNA reads against a reference genome; (4) aligning Illumina single- or paired-end reads; (5) assembly-to-assembly alignment; (6) full-genome alignment between two closely related species with divergence below ~15%.

### Methylation / modified basecalling

* [nanopolish](https://github.com/jts/nanopolish)<br>Software package for signal-level analysis of Oxford Nanopore sequencing data. Nanopolish can calculate an improved consensus sequence for a draft genome assembly, detect base modifications, call SNPs and indels with respect to a reference genome and more.

* [megalodon](https://github.com/nanoporetech/megalodon)<br>Megalodon is a research tool for per-read and aggregated modified base and sequence variant calling by anchoring the information rich basecalling neural network output to a reference genome/transriptome. Megalodon takes raw nanopore reads as input and produces multiple outputs, primarily including basecalls (FASTA), reference mappings (SAM/BAM/CRAM), sequence variant calls (per-read and VCF) and modified base calls (per-read and bedgraph/bedmethyl/VCF).

* [tombo](https://github.com/nanoporetech/tombo)<br>Tombo is a suite of tools primarily for the identification of modified nucleotides from nanopore sequencing data. Tombo also provides tools for the analysis and visualization of raw nanopore signal.

* [f5c](https://github.com/hasindu2008/f5c)<br>An optimised re-implementation of the *call-methylation* and *eventalign* modules in [Nanopolish](https://github.com/jts/nanopolish). Given a set of basecalled Nanopore reads and the raw signals, *f5c call-methylation* detects the methylated cytosine and *f5c eventalign* aligns raw nanopore DNA signals (events) to the base-called read. *f5c* can optionally utilise NVIDIA graphics cards for acceleration.

  First the reads have to be indexed using `f5c index`. Then invoke `f5c call-methylation` to detect methylated cytosine bases. Finally, you may use `f5c meth-freq` to obtain methylation frequencies. Alternatively, invoke `f5c eventalign` to perform event alignment. The results are almost the same as from nanopolish except a few differences due to floating point approximations.

### Tandem Repeats

* [STRique](https://github.com/giesselmann/STRique)<br>STRique is a python package to analyze repeat expansion and methylation states of short tandem repeats (STR) in Oxford Nanopore Technology (ONT) long read sequencing data.
* [NanoSatellite](https://github.com/arnederoeck/NanoSatellite)<br>Dynamic time warping of Oxford Nanopore squiggle data to characterize tandem repeats.

### Classification

* [Centrifuge]( https://github.com/infphilo/centrifuge)<br>Centrifuge is a novel microbial classification engine that enables rapid, accurate and sensitive labeling of reads and quantification of species on desktop computers. The system uses a novel indexing scheme based on the Burrows-Wheeler transform (BWT) and the Ferragina-Manzini (FM) index, optimized specifically for the metagenomic classification problem. Centrifuge requires a relatively small index (4.7 GB for all complete bacterial and viral genomes plus the human genome) and classifies sequences at very high speed, allowing it to process the millions of reads from a typical high-throughput DNA sequencing run within a few minutes. Together these advances enable timely and accurate analysis of large metagenomics data sets on conventional desktop computers
* [Kraken2]( https://ccb.jhu.edu/software/kraken2/)<br>Kraken 2 is the newest version of Kraken, a taxonomic classification system using exact k-mer matches to achieve high accuracy and fast classification speeds. This classifier matches each k-mer within a query sequence to the lowest common ancestor (LCA) of all genomes containing the given k-mer. The k-mer assignments inform the classification algorithm.
* [Bracken]( https://ccb.jhu.edu/software/bracken/)<br>Bracken (Bayesian Reestimation of Abundance with KrakEN) is a highly accurate statistical method that computes the abundance of species in DNA sequences from a metagenomics sample. Braken uses the taxonomy labels assigned by Kraken, a highly accurate metagenomics classification algorithm, to estimate the number of reads originating from each species present in a sample. [Kraken](https://ccb.jhu.edu/software/kraken/) classifies reads to the best matching location in the taxonomic tree, but does not estimate abundances of species. We use the Kraken database itself to derive probabilities that describe how much sequence from each genome is identical to other genomes in the database, and combine this information with the assignments for a particular sample to estimate abundance at the species level, the genus level, or above. Combined with the Kraken classifier, Bracken produces accurate species- and genus-level abundance estimates even when a sample contains two or more near-identical species.

### FAST5 file management

* [ont_fast5_api]( https://github.com/nanoporetech/ont_fast5_api )<br>ont_fast5_api is a simple interface to HDF5 files of the Oxford Nanopore .fast5 file format.
